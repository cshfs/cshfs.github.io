<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>8086 Assembly Runner (Live VM: TASM/TLINK, uploads)</title>

  <!-- js-dos v8 CDN -->
  <link rel="stylesheet" href="https://v8.js-dos.com/latest/js-dos.css">
  <script src="https://v8.js-dos.com/latest/js-dos.js"></script>

  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
    .grid { display: grid; grid-template-columns: 1fr 820px; gap: 16px; align-items: start; }
    textarea { width: 100%; height: 560px; font-family: Consolas, Menlo, monospace; font-size: 14px; }
    #dosbox { width: 800px; height: 600px; border: 1px solid #ccc; }
    #runBtn, #resetBtn { padding: 8px 14px; font-size: 16px; }
    .bar { display:flex; gap:12px; align-items:center; margin:8px 0 0; flex-wrap: wrap; }
    .small { color:#666; font-size: 12px; }
    .uploads { margin-top: 8px; }
    .uploads ul { margin: 6px 0 0; padding-left: 18px; }
    .uploads li { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    h1 { margin-top: 0; }
    .chip { display:inline-block; padding:2px 6px; border:1px solid #ccc; border-radius: 6px; background:#fafafa; }
  </style>
</head>
<body>
  <h1>8086 Assembly Runner</h1>
  <p class="small">
    Paste TASM-style source (<code>.model small</code> etc.), optionally upload files (e.g., <code>TEST.BMP</code>, <code>DATA.TXT</code>), then click <b>Run</b>.
    The emulator stays alive between runs; your program’s generated files remain available until you click <b>Reset VM</b>.
    Your source text is saved locally on each run.
  </p>

  <div class="grid">
    <div>
      <textarea id="code"></textarea>
      <div class="bar">
        <input type="file" id="fileInput" multiple />
        <button id="runBtn">Run</button>
        <button id="resetBtn" title="Recreate a fresh DOS VM (does not clear your editor text)">Reset VM</button>
        <span id="status" class="small"></span>
      </div>

      <div class="uploads">
        <span class="small">Files to inject/overwrite in <span class="chip">C:\</span> (original → DOS 8.3):</span>
        <ul id="fileList"></ul>
      </div>
    </div>

    <div>
      <div id="dosbox"></div>
      <p class="small">
        Tip: refer to uploaded files by their DOS 8.3 names (e.g., <code>TEST.BMP</code>, <code>DATA.TXT</code>).  
        <b>Keyboard & mouse</b> work inside the DOS frame—click inside to focus.
      </p>
    </div>
  </div>

  <script>
  // One-time guard (in case this file is included twice by a site template)
  if (!window.__asmRunnerInit__) {
    window.__asmRunnerInit__ = true;

    // js-dos core
    const WDO_URL = "https://v8.js-dos.com/latest/wdosbox.js";

    // Elements
    const elCode   = document.getElementById('code');
    const elRun    = document.getElementById('runBtn');
    const elReset  = document.getElementById('resetBtn');
    const elStat   = document.getElementById('status');
    const elDos    = document.getElementById('dosbox');
    const elInput  = document.getElementById('fileInput');
    const elList   = document.getElementById('fileList');

    const LS_KEY = "asm-editor-text-v1";
    const encoder = new TextEncoder();

    // Default starter code
    const DEFAULT_SRC = [
      "; Sample TASM program (EXE) for 8086",
      ".model small",
      ".stack 100h",
      ".data",
      "msg db 'Hello from TASM in a live VM!$'",
      ".code",
      "main proc",
      "    mov ax, @data",
      "    mov ds, ax",
      "    mov dx, offset msg",
      "    mov ah, 9",
      "    int 21h",
      "    mov ax, 4C00h",
      "    int 21h",
      "main endp",
      "end main"
    ].join("\n");

    // Load persisted text (or default)
    elCode.value = localStorage.getItem(LS_KEY) || DEFAULT_SRC;

    // Maintain uploaded files in-memory for this tab session
    // { original: "...", dosName: "FOO.BMP", bytes: Uint8Array }
    let uploads = [];

    // DOS 8.3 name conversion
    function toDos83(name) {
      const idx = name.lastIndexOf(".");
      let base = (idx >= 0 ? name.slice(0, idx) : name).toUpperCase();
      let ext  = (idx >= 0 ? name.slice(idx + 1) : "").toUpperCase();
      const clean = s => s.replace(/[^A-Z0-9]/g, "_");
      base = clean(base).slice(0, 8);
      ext  = clean(ext).slice(0, 3);
      return ext ? `${base}.${ext}` : base;
    }

    // Handle uploads → memory
    elInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;

      const readAll = files.map(f => new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve({ file: f, bytes: new Uint8Array(fr.result) });
        fr.onerror = () => reject(fr.error || new Error("Failed to read " + f.name));
        fr.readAsArrayBuffer(f);
      }));

      try {
        const read = await Promise.all(readAll);
        for (const { file, bytes } of read) {
          let dos = toDos83(file.name);
          // avoid DOS name collisions within this session
          let candidate = dos, i = 1;
          while (uploads.some(u => u.dosName === candidate)) {
            const dot = dos.lastIndexOf(".");
            const b = dot >= 0 ? dos.slice(0, dot) : dos;
            const e = dot >= 0 ? dos.slice(dot) : "";
            const suffix = String(i++).slice(-1);
            candidate = (b.slice(0, Math.max(0, 8 - 1)) + suffix) + e;
          }
          const existing = uploads.findIndex(u => u.original === file.name);
          if (existing >= 0) uploads[existing] = { original: file.name, dosName: candidate, bytes };
          else uploads.push({ original: file.name, dosName: candidate, bytes });
        }
        // Update UI list
        elList.innerHTML = "";
        for (const u of uploads) {
          const li = document.createElement("li");
          li.textContent = `${u.original}  →  ${u.dosName}`;
          elList.appendChild(li);
        }
        elStat.textContent = `${uploads.length} file(s) staged`;
      } catch (err) {
        console.error(err);
        elStat.textContent = "Error reading files";
      }
    });

    // Toolchain buffers
    let tasmBuf = null, tlinkBuf = null, dpmiBuf = null, rtmBuf = null;

    async function preloadTools() {
      const fetchBinary = async (path, { optional = false } = {}) => {
        const resp = await fetch(path);
        if (!resp.ok) {
          if (optional) return null;
          throw new Error(path + " not found");
        }
        const ab = await resp.arrayBuffer();
        return new Uint8Array(ab);
      };
      [tasmBuf, tlinkBuf, dpmiBuf, rtmBuf] = await Promise.all([
        fetchBinary("tools/TASM.EXE"),
        fetchBinary("tools/TLINK.EXE"),
        fetchBinary("tools/DPMI16BI.OVL", { optional: true }),
        fetchBinary("tools/RTM.EXE",       { optional: true })
      ]);
    }

    // Provide a tiny DOSBox config so the player starts straight into DOS (no picker)
    const BASIC_CONF = `
[sdl]
fullscreen=false

[autoexec]
@echo off
echo Live DOS VM starting...
`;

    // Live VM handles
    let fsHandle = null;   // filesystem API from js-dos
    let mainExec = null;   // function to run DOS commands

    // Create or recreate the VM (now with a config to suppress the launcher)
    async function createVm() {
      return new Promise((resolve) => {
        elDos.innerHTML = ""; // clear previous canvas if any
        Dos(elDos, {
          wdosboxUrl: WDO_URL,
          dosboxConf: BASIC_CONF
        }).ready(async (fs, main) => {
          fsHandle = fs;
          mainExec = main;
          // Mount current working dir as C: and switch to it
          await mainExec(["-c", "MOUNT C .", "-c", "C:"]);
          // Friendly banner
          await mainExec(["-c", "ECHO Live DOS VM ready"]);
          resolve();
        });
      });
    }

    // Ensure VM exists
    async function ensureVm() {
      if (!fsHandle || !mainExec) {
        await createVm();
      }
    }

    // Write/overwrite a file into C:\
    async function writeFileDos(path, bytes) {
      await fsHandle.createFile(path, bytes);
    }

    // Build script
    function buildBatBytes() {
      const lines = [
        "@echo off",
        "echo Assembling MAIN.ASM (TASM)...",
        "TASM /q MAIN.ASM > BUILD.LOG",
        "if errorlevel 1 goto ERR",
        "echo Linking MAIN.OBJ (TLINK)...",
        "TLINK MAIN.OBJ,,NUL,; >> BUILD.LOG",
        "if errorlevel 1 goto ERR",
        "echo Running MAIN.EXE...",
        "MAIN.EXE",
        "goto END",
        ":ERR",
        "echo.",
        "echo ===== BUILD FAILED =====",
        "type BUILD.LOG",
        ":END",
        "echo.",
        "echo ===== DONE ====="
      ].join("\r\n");
      return new TextEncoder().encode(lines);
    }

    // Write toolchain (once) if missing, else skip
    async function ensureToolchain() {
      if (!tasmBuf || !tlinkBuf) {
        await preloadTools();
      }
      // Always (re)write to be safe (tiny files, keeps it simple)
      await writeFileDos("TASM.EXE",  tasmBuf);
      await writeFileDos("TLINK.EXE", tlinkBuf);
      if (dpmiBuf) await writeFileDos("DPMI16BI.OVL", dpmiBuf);
      if (rtmBuf)  await writeFileDos("RTM.EXE",      rtmBuf);
    }

    // Run build inside the SAME VM
    async function runBuildInVm(sourceText) {
      // Persist editor text locally
      localStorage.setItem(LS_KEY, sourceText);

      // Ensure VM & tools in place
      await ensureVm();
      await ensureToolchain();

      // Write/update source and batch
      await writeFileDos("MAIN.ASM", new TextEncoder().encode(sourceText));
      await writeFileDos("BUILD.BAT", buildBatBytes());

      // Inject/overwrite uploaded files
      for (const u of uploads) {
        await writeFileDos(u.dosName, u.bytes);
      }

      // Execute BUILD.BAT from C:\
      await mainExec(["-c", "CALL BUILD"]);
    }

    // RUN button: write files → run build in live VM
    elRun.addEventListener('click', async () => {
      try {
        elRun.disabled = true;
        elReset.disabled = true;
        elStat.textContent = "Running...";

        const code = elCode.value || "";
        await runBuildInVm(code);

        elStat.textContent = "Done. (VM is still running — edit and Run again)";
      } catch (e) {
        console.error(e);
        elStat.textContent = "Error: " + (e?.message || e);
      } finally {
        elRun.disabled = false;
        elReset.disabled = false;
      }
    });

    // RESET VM: recreate a fresh emulator (does NOT clear editor text or uploads)
    elReset.addEventListener('click', async () => {
      try {
        elRun.disabled = true;
        elReset.disabled = true;
        elStat.textContent = "Resetting VM...";
        fsHandle = null;
        mainExec = null;
        await createVm();
        elStat.textContent = "Fresh VM ready.";
      } catch (e) {
        console.error(e);
        elStat.textContent = "Error resetting VM";
      } finally {
        elRun.disabled = false;
        elReset.disabled = false;
      }
    });

    // Auto-create VM on first load so students see the console straight away
    (async () => {
      elStat.textContent = "Starting VM...";
      await createVm();
      elStat.textContent = "VM ready.";
    })();
  }
  </script>
</body>
</html>
