<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DOSBox — Editor + Run</title>

<!-- js-dos (local in /dosbox) -->
<link rel="stylesheet" href="js-dos.css" />
<script src="js-dos.js"></script>

<!-- CodeMirror 5 (local) -->
<link rel="stylesheet" href="codemirror.min.css">
<script src="codemirror.min.js"></script>

<!-- Folding core + gutter (local) -->
<link rel="stylesheet" href="foldgutter.min.css">
<script src="foldcode.min.js"></script>
<script src="foldgutter.min.js"></script>

<!-- TASM mode -->
<script src="tasm.js"></script>

<style>
  :root{
    /* exact outer heights match for input + buttons */
    --ctl-h: 26px;
    --ctl-b: 2px;   /* border width */
    --ctl-py: 0px;  /* vertical padding inside content box */
  }

  /* Force white everywhere */
  html, body { height: 100%; background:#fff !important; color:#000; }
  body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  body, main, section, #dosbox, #dosbox * { background:#fff !important; }

  html.no-scroll, body.no-scroll { overflow-y: hidden; }
  main { width: min(1280px, 95vw); margin: 0 auto; padding: 10px; }
  section { margin: 10px 0; }

  /* Loading */
  #loading { padding: 4px 0; }
  #status { font-size: 13px; margin: 4px 0; }
  progress { width: 220px; height: 10px; vertical-align: middle; }

  /* Workspace */
  #workspace { display:flex; flex-direction:column; gap:8px; padding-bottom:120px; }
  #workspace.no-safe { padding-bottom: 0; }

  /* Controls — flat, same outer height, box-sizing border-box */
  .row { display:flex; gap:6px; flex-wrap:wrap; align-items:center; }

  .btn{
    box-sizing: border-box;
    display: inline-flex; align-items: center; justify-content: center;
    font: inherit; font-size: 12px;
    height: var(--ctl-h);
    padding: var(--ctl-py) 10px;
    border: var(--ctl-b) solid #000;
    border-radius: 0;
    background:#fff; color:#000; cursor:pointer;
  }
  .btn:hover { background:#f4f4f4; }
  .btn[disabled] { opacity:.55; cursor:not-allowed; }

  #fileName{
    box-sizing: border-box;
    -webkit-appearance: none; appearance: none;
    font: inherit; font-size: 18px;
    height: var(--ctl-h);
    padding: var(--ctl-py) 10px;
    border: var(--ctl-b) solid #000; border-radius:0;
    width: 260px; background:#fff; color:#000;
  }

  label.file { position: relative; }
  label.file input[type=file]{ position:absolute; inset:0; opacity:0; cursor:pointer; }

  /* Editor */
  .editor-wrap { min-height:0; display:flex; }
  .CodeMirror { width:100%; border:2px solid #000; }
  .CodeMirror-focused { outline: 2px solid #1115; }
  .cm-locked .CodeMirror { opacity:.5; pointer-events:none; }
  .CodeMirror-gutters { border-right:2px solid #000; }
  .CodeMirror-foldgutter { width:16px; cursor:pointer; }
  .cm-s-default, .CodeMirror, .CodeMirror-scroll, .CodeMirror-gutters { background:#fff !important; color:#000; }

  /* Fold markers */
  .CodeMirror-foldmarker { color:#000; font-weight:700; cursor:pointer; }
  .CodeMirror-foldgutter-open:after  { content:"▾"; color:#000; }
  .CodeMirror-foldgutter-closed:after{ content:"▸"; color:#000; }

  /* Emulator hidden until Start */
  #emuSection { display:none; }

  /* DOSBox */
  #dosbox { border:2px solid #000; width:100%; height:600px; aspect-ratio:1050/600; position:relative; }
  #dosbox canvas { width:100% !important; height:100% !important; display:block; background:#000 !important; }

  /* Force js-dos wrappers to white */
  :where(.dosbox-root, .dosbox-container, .dosbox-viewport, .dosbox-overlay, .dosbox-loader, .dosbox){
    background:#fff !important; box-shadow:none !important; border-color:#fff !important;
  }

  /* Notepad++-like TASM colors */
  .cm-builtin       { color:#0070C0; }
  .cm-variable-2    { color:#0070C0; }
  .cm-tasm-directive{ color:#7A3E9D; }
  .cm-tasm-label    { color:#7A3E9D; font-weight:600; }
  .cm-keyword       { color:#0000FF; }
  .cm-atom          { color:#008080; font-style:italic; }
  .cm-number        { color:#C05000; }
  .cm-comment       { color:#008000; }
  .cm-string        { color:#A31515; }
</style>

<script>
/* COOP/COEP SW */
(function registerCOI() {
  if (!('serviceWorker' in navigator)) return;
  const swUrl = new URL('./coi-sw.js', location.href);
  const KEY = 'coi-reloaded-once';
  navigator.serviceWorker.register(swUrl, { scope: './' }).then(async () => {
    if (!navigator.serviceWorker.controller && !sessionStorage.getItem(KEY)) {
      try { await navigator.serviceWorker.ready; sessionStorage.setItem(KEY,'1'); location.reload(); } catch {}
    }
  });
  navigator.serviceWorker.addEventListener('controllerchange', () => { sessionStorage.removeItem(KEY); });
})();
</script>
</head>
<body class="no-scroll">
<main>
  <section id="loading">
    <div id="status">Preparing emulator…</div>
    <progress id="prog" value="0" max="100"></progress>
    <span id="progText"></span>
    <div id="coiNote" style="font-size:12px;color:#333;"></div>
  </section>

  <section id="workspace" class="no-safe">
    <div class="row" id="nameRow">
      <input id="fileName" type="text" value="base.asm" aria-label="File name">
      <button id="saveBtn" class="btn" type="button">Download .ASM</button>
      <button id="loadBtn" class="btn" type="button">Load .ASM</button>
      <input id="loader" type="file" accept=".asm,.inc,.txt" style="display:none" />
      <label class="file btn">Choose asset files<input id="fileInput" type="file" multiple /></label>
      <button id="startBtn" class="btn" type="button" disabled>Start</button>
    </div>

    <div class="editor-wrap">
<textarea id="editorTA">IDEAL
MODEL small
STACK 100h
DATASEG
; --------------------------
; Your variables here
; --------------------------
msg db 'Hello!$'

CODESEG
start:
  mov ax, @data
  mov ds, ax
; --------------------------
; Your code here
; --------------------------
  call printHello
  
  
exit:
  mov ax, 4c00h
  int 21h

; --------------------------
; Your procedures here
; --------------------------
Proc printHello
  mov dx, OFFSET msg
  mov ah, 09h
  int 21h
  mov ax, 4C00h
  int 21h
  ret
endp

END start
</textarea>
    </div>
  </section>

  <section id="emuSection">
    <div id="dosbox" aria-label="DOSBox frame"></div>
    <div class="row" style="margin-top:8px;">
      <button id="stopBtn" class="btn" type="button">Stop</button>
    </div>
  </section>
</main>

<script>
(function(){
  /* ===== Persistence (filename + text) ===== */
  const LS_KEY_NAME = 'dos_editor_name_v1';
  const LS_KEY_TEXT = 'dos_editor_text_v1';

  const htmlEl = document.documentElement;
  const bodyEl = document.body;
  const workspace = document.getElementById('workspace');
  const emuSection = document.getElementById('emuSection');
  const mainEl = document.querySelector('main');

  /* ===== CodeMirror ===== */
  const cm = CodeMirror.fromTextArea(document.getElementById('editorTA'), {
    lineNumbers: true,
    mode: 'tasm',
    indentUnit: 2,
    tabSize: 2,
    foldGutter: true,
    gutters: ["CodeMirror-linenumbers","CodeMirror-foldgutter"]
  });

  /* --- Robust TASM folding: folds a label/PROC/SEGMENT until the next block start.
         Comments and blank lines do NOT terminate the fold. --- */
  (function() {
    function isBlockStart(s){
      if (!s) return false;
      if (/^\s*;/.test(s)) return false;           // comment is not a block start
      if (/^[A-Za-z_.$][\w.$]*\s*:/ .test(s)) return true;         // label:
      if (/\bproc\b/i.test(s)) return true;                          // PROC
      if (/^\s*endp\b/i.test(s)) return true;                        // ENDP
      if (/^\s*(IDEAL|MODEL|CODESEG|DATASEG|STACK|ENDS?)\b/i.test(s)) return true; // segments
      if (/^\s*END\b/i.test(s)) return true;                         // END start
      return false;
    }
    function tasmFold(cmInst, start) {
      const head = cmInst.getLine(start.line) || "";
      if (!isBlockStart(head)) return null;

      const last = cmInst.lineCount();
      let i = start.line + 1;
      while (i < last) {
        const t = cmInst.getLine(i) || "";
        if (/^\s*endp\b/i.test(t) && /\bproc\b/i.test(head)) { i++; break; } // include ENDP for PROC
        if (isBlockStart(t)) break;  // next block starts
        i++;
      }
      if (i <= start.line + 1) return null;

      return {
        from: CodeMirror.Pos(start.line, head.length),
        to:   CodeMirror.Pos(i - 1, (cmInst.getLine(i - 1) || "").length)
      };
    }
    CodeMirror.registerHelper("fold", "tasm", tasmFold);
  })();

  // Use our TASM range finder
  cm.setOption("foldOptions", { rangeFinder: CodeMirror.fold.tasm });

  // Enable gutter clicking
  cm.on('gutterClick', (inst, line, g) => {
    if (g === 'CodeMirror-foldgutter') {
      inst.foldCode(CodeMirror.Pos(line, 0), { rangeFinder: CodeMirror.fold.tasm });
    }
  });

  /* ===== Persist filename + content ===== */
  const fileNameEl = document.getElementById('fileName');
  const savedName = localStorage.getItem(LS_KEY_NAME);
  const savedText = localStorage.getItem(LS_KEY_TEXT);
  if (savedName) fileNameEl.value = savedName;
  if (savedText) cm.setValue(savedText);

  function persistNow(){
    localStorage.setItem(LS_KEY_NAME, fileNameEl.value || 'base.asm');
    localStorage.setItem(LS_KEY_TEXT, cm.getValue());
  }
  fileNameEl.addEventListener('input', persistNow);
  cm.on('change', () => { clearTimeout(persistNow._t); persistNow._t = setTimeout(persistNow, 120); });

  function autoDetectTasm(filename) {
    cm.setOption("mode", filename.toLowerCase().endsWith(".asm") ? "tasm" : null);
  }
  fileNameEl.addEventListener("input", () => autoDetectTasm(fileNameEl.value));
  autoDetectTasm(fileNameEl.value);

  /* ===== Sizing ===== */
  const nameRow = document.getElementById('nameRow');
  const loadingBox = document.getElementById('loading');

  function resizeEditor() {
    const vh = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
    const mainPad = getComputedStyle(mainEl);
    const pad = parseInt(mainPad.paddingTop) + parseInt(mainPad.paddingBottom);
    const wsStyle = getComputedStyle(workspace);
    const wsMargins = parseInt(wsStyle.marginTop) + parseInt(wsStyle.marginBottom);
    const loadingH = (loadingBox && loadingBox.offsetParent !== null) ? loadingBox.offsetHeight : 0;
    const nameH = nameRow.offsetHeight;
    const SAFE = workspace.classList.contains('no-safe') ? 0 : 120;
    const target = Math.max(180, vh - pad - wsMargins - loadingH - nameH - SAFE);
    cm.setSize(null, target);
    cm.refresh();
  }
  window.addEventListener('resize', resizeEditor);
  if (window.visualViewport) window.visualViewport.addEventListener('resize', resizeEditor);
  setTimeout(resizeEditor, 0);

  /* ===== DOSBox sizing ===== */
  const AR_W = 1050, AR_H = 600;
  const elDos = document.getElementById('dosbox');
  function sizeDosbox() {
    const pageW = mainEl.clientWidth;
    const viewportH = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
    const stopRow = 50, margin = 20;
    const availH = Math.max(240, viewportH - stopRow - margin);
    const hFromW = Math.floor(pageW * (AR_H / AR_W));
    const targetH = (hFromW <= availH) ? hFromW : availH;
    const targetW = (hFromW <= availH) ? pageW : Math.floor(availH * (AR_W / AR_H));
    elDos.style.width = targetW + 'px';
    elDos.style.height = targetH + 'px';
  }

  /* ===== Helpers ===== */
  const encoder = new TextEncoder();
  function toDos83(name){
    const i = name.lastIndexOf('.');
    let b = (i>=0?name.slice(0,i):name).toUpperCase();
    let e = (i>=0?name.slice(i+1):'').toUpperCase();
    const clean = s=>s.replace(/[^A-Z0-9]/g,'_');
    b = clean(b).slice(0,8); e = clean(e).slice(0,3);
    return e?`${b}.${e}`:b;
  }

  const DOS_CONF = `
[sdl]
fullscreen=false

[autoexec]
@echo off
mount c .
c:
cls
BUILD
`;

  function buildBatFor(dosAsmName){
    const base = dosAsmName.replace(/\.[^.]*$/,'');
    const lines = [
      '@echo off',
      'echo Assembling ' + dosAsmName,
      'TASM /zi /q ' + dosAsmName,
      'if errorlevel 1 goto ERR',
      'echo Linking ' + base + '.OBJ',
      'TLINK /v ' + base + '.OBJ,,NUL,;',
      'if errorlevel 1 goto ERR',
      'echo Running ' + base + '.EXE',
      base + '.EXE',
      'echo.',
      'goto END',
      ':ERR',
      'echo Build failed.',
      ':END'
    ];
    return encoder.encode(lines.join("\r\n") + "\r\n");
  }

  let toolBufs = new Map();
  let player = null;
  const bag = new Map();

  function startDosWith(initFs){
    if (player && typeof player.exit === 'function') { try { player.exit(); } catch {} }
    elDos.innerHTML = '';
    player = window.Dos(elDos, {
      pathPrefix: "emulators/",
      dosboxConf: DOS_CONF,
      initFs,
      noCloud: true,
      noNetworking: true,
      kiosk: true,
      autostart: true
    });
    requestAnimationFrame(() => setTimeout(sizeDosbox, 60));
  }

  function revealAndScroll() {
    htmlEl.classList.remove('no-scroll');
    bodyEl.classList.remove('no-scroll');
    emuSection.style.display = 'block';
    workspace.classList.remove('no-safe');
    requestAnimationFrame(() => {
      resizeEditor();
      sizeDosbox();
      emuSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      setTimeout(() => window.scrollTo({ top: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight), behavior: 'smooth' }), 160);
    });
  }

  function waitForCanvasAndNudge() {
    const t0 = performance.now();
    (function tick(){
      const c = document.querySelector('#dosbox canvas');
      if (c) {
        setTimeout(() =>
          window.scrollTo({ top: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight), behavior: 'smooth' })
        , 120);
      } else if (performance.now() - t0 < 5000) {
        requestAnimationFrame(tick);
      }
    })();
  }

  /* Preload */
  const status = document.getElementById('status');
  const prog = document.getElementById('prog');
  const progText = document.getElementById('progText');

  async function preloadAll(){
    status.textContent = 'Caching emulator and tools…';
    const files = [
      { path:'emulators/wdosbox.wasm', url:'emulators/wdosbox.wasm', required:true,  keepInMemory:false },
      { path:'emulators/wdosbox.js',   url:'emulators/wdosbox.js',   required:false, keepInMemory:false },
      { path:'TASM.EXE',     url:'tools/TASM.EXE',     required:true,  keepInMemory:true },
      { path:'TLINK.EXE',    url:'tools/TLINK.EXE',    required:true,  keepInMemory:true },
      { path:'DPMI16BI.OVL', url:'tools/DPMI16BI.OVL', required:false, keepInMemory:true },
      { path:'RTM.EXE',      url:'tools/RTM.EXE',      required:false, keepInMemory:true },
      { path:'TD.EXE',       url:'tools/TD.EXE',       required:false, keepInMemory:true },
      { path:'TDCONFIG.TD',  url:'tools/TDCONFIG.TD',  required:false, keepInMemory:true },
    ];
    const cache = await caches.open('dosbox-prewarm-v10');
    const mem = new Map();

    let total = files.length, done = 0;
    prog.max = total; prog.value = 0; progText.textContent = `0/${total}`;

    for (const f of files) {
      const hit = await cache.match(f.url);
      if (hit) {
        done++; prog.value = done; progText.textContent = `${done}/${total}`;
        if (f.keepInMemory) mem.set(f.path, new Uint8Array(await hit.clone().arrayBuffer()));
      }
    }
    for (const f of files) {
      if (await cache.match(f.url)) continue;
      const resp = await fetch(new Request(f.url, { cache:'reload' })).catch(()=>null);
      if (!resp || !resp.ok) {
        if (f.required) throw new Error('Network error ' + f.url);
      } else {
        cache.put(f.url, resp.clone()).catch(()=>{});
        if (f.keepInMemory) mem.set(f.path, new Uint8Array(await resp.clone().arrayBuffer()));
      }
      done++; prog.value = done; progText.textContent = `${done}/${total}`;
    }
    for (const f of files) {
      if (!f.keepInMemory || mem.has(f.path)) continue;
      const hit = await cache.match(f.url);
      if (hit) mem.set(f.path, new Uint8Array(await hit.clone().arrayBuffer()));
    }
    toolBufs = new Map();
    for (const [k,v] of mem.entries()) toolBufs.set(k.split('/').pop(), v);

    document.getElementById('loading').style.display = 'none';
    document.getElementById('startBtn').disabled = false;

    resizeEditor();
  }

  /* UI actions */
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const loader  = document.getElementById('loader');
  const elInput = document.getElementById('fileInput');
  const startBtn= document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');

  saveBtn.addEventListener('click', ()=>{
    const name = (fileNameEl.value || 'BASE.ASM');
    const blob = new Blob([cm.getValue()], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name.toUpperCase();
    a.click();
    URL.revokeObjectURL(a.href);
    persistNow();
  });

  loadBtn.addEventListener('click', ()=> loader.click());
  loader.addEventListener('change', async ()=>{
    const f = loader.files && loader.files[0];
    if (!f) return;
    cm.setValue(await f.text());
    fileNameEl.value = f.name;
    loader.value = '';
    cm.refresh();
    resizeEditor();
    cm.focus();
    persistNow();
  });

  elInput.addEventListener('change', ()=>{ for (const f of Array.from(elInput.files || [])) bag.set(f.name, f); elInput.value=''; });

  startBtn.addEventListener('click', async ()=>{
    try {
      persistNow();

      cm.setOption('readOnly', true);
      workspace.classList.add('cm-locked');
      startBtn.disabled = true;

      revealAndScroll();

      const dosAsmName = toDos83(fileNameEl.value || 'base.asm');
      const asmBytes = encoder.encode(cm.getValue());

      const initFs = [
        { path: 'TASM.EXE',  contents: toolBufs.get('TASM.EXE') },
        { path: 'TLINK.EXE', contents: toolBufs.get('TLINK.EXE') },
        { path: dosAsmName,  contents: asmBytes },
        { path: 'BUILD.BAT', contents: buildBatFor(dosAsmName) },
      ];
      for (const p of ['DPMI16BI.OVL','RTM.EXE','TD.EXE','TDCONFIG.TD']) {
        const buf = toolBufs.get(p); if (buf) initFs.push({ path: p, contents: buf });
      }
      for (const f of Array.from(bag.values())) {
        initFs.push({ path: toDos83(f.name), contents: new Uint8Array(await f.arrayBuffer()) });
      }

      startDosWith(initFs);
      waitForCanvasAndNudge();

    } catch (e) {
      console.error(e);
      alert('Start failed. See console.');
    }
  });

  stopBtn.addEventListener('click', ()=>{
    window.scrollTo({ top: 0, behavior: 'smooth' });
    setTimeout(()=>location.reload(), 250);
  });

  // Prevent scroll initially
  htmlEl.classList.add('no-scroll');
  bodyEl.classList.add('no-scroll');

  (async ()=>{
    // proceed even if COI is not ready
    const t0 = performance.now();
    while (performance.now() - t0 < 8000) {
      if (navigator.serviceWorker?.controller && self.crossOriginIsolated) break;
      await new Promise(r=>setTimeout(r,120));
    }
    try { await preloadAll(); }
    catch (e) { status.textContent = 'Preload failed. Hard-refresh.'; console.error(e); }
  })();
})();
</script>
</body>
</html>
