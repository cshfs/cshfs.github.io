<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DOSBox Editor → Run</title>

  <!-- Local js-dos -->
  <link rel="stylesheet" href="js-dos.css" />
  <script src="js-dos.js"></script>

  <!-- CodeMirror 5 (CDN) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.17/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.17/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.17/mode/gas/gas.min.js"></script>

  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: #fff; color: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: grid; place-items: start center;
    }
    main { width: 100%; max-width: 1100px; padding: 16px; }
    h1 { margin: 0 0 12px; font-size: 20px; font-weight: 600; }

    .toolbar { display:flex; gap:8px; align-items:center; margin: 10px 0 8px; }
    .toolbar input[type="text"] {
      font: inherit; padding: 8px 10px; border: 1px solid #e5e7eb; border-radius: 6px; width: 220px;
    }
    .btn {
      font: inherit; font-size: 14px; padding: 10px 14px; border-radius: 8px;
      border: 1px solid #e5e7eb; background: #f8fafc; color: #111; cursor: pointer;
    }
    .btn[disabled]{ opacity:.6; cursor:not-allowed; }

    .cm-wrap { border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden; }
    .CodeMirror { height: 520px; max-width: 1000px; }

    #bgPrep { font-size: 13px; color: #374151; margin-top: 8px; }

    /* Modal (floating pane) */
    .modal-overlay {
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.4); z-index: 99999;
    }
    .modal-overlay.open { display: flex; }
    .modal {
      width: min(1000px, 96vw);
      background: #fff; border-radius: 10px; border: 1px solid #e5e7eb;
      padding: 12px; box-shadow: 0 10px 40px rgba(0,0,0,.25);
      max-height: 96vh; display: flex; flex-direction: column; gap: 8px;
    }
    .modal .header { display:flex; align-items:center; justify-content: space-between; }
    .modal h2 { margin: 0; font-size: 16px; font-weight: 600; }
    .modal .actions { display:flex; gap:8px; align-items:center; }
    .status-line { font-size:13px; color:#374151; display:flex; align-items:center; gap:8px; }
    .error-line { font-size:13px; color:#b91c1c; display:none; }
    .error-line.show { display:block; }

    #dosbox {
      width: 100%; aspect-ratio: 1050/600;
      background:#000; border: 1px solid #e5e7eb;
    }
    .inline-load { display:flex; gap:8px; align-items:center; }
    progress { width: 240px; height: 12px; }
  </style>

  <!-- Register SW early (COOP/COEP + caching). Reload once when ready. -->
  <script>
  (function registerCOI() {
    if (!('serviceWorker' in navigator)) return;
    const swUrl = new URL('./coi-sw.js', location.href);
    const KEY = 'coi-reloaded-once';
    navigator.serviceWorker.register(swUrl, { scope: './' }).then(async () => {
      if (!navigator.serviceWorker.controller && !sessionStorage.getItem(KEY)) {
        try { await navigator.serviceWorker.ready; sessionStorage.setItem(KEY, '1'); location.reload(); } catch {}
      }
    });
    navigator.serviceWorker.addEventListener('controllerchange', () => { sessionStorage.removeItem(KEY); });
  })();
  </script>
</head>
<body>
  <main>
    <h1>Editor</h1>

    <div class="toolbar">
      <input id="fileName" type="text" value="HELLO.ASM" aria-label="File name">
      <button id="runBtn" class="btn" type="button">Run file</button>
    </div>

    <div class="cm-wrap">
      <textarea id="editorTA">; 16-bit DOS example for TASM/TLINK
.MODEL  small
.STACK  100h
.DATA
msg db 'Hello from editor!$'
.CODE
main PROC
  mov ax, @data
  mov ds, ax
  mov dx, OFFSET msg
  mov ah, 09h
  int 21h
  mov ax, 4C00h
  int 21h
main ENDP
END main
</textarea>
    </div>

    <div id="bgPrep">Preparing emulator in the background…</div>
  </main>

  <!-- Floating pane (modal) -->
  <div id="overlay" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="header">
        <h2>DOSBox</h2>
        <div class="actions">
          <button id="rerunBtn" class="btn" type="button" title="Re-run with current editor buffer">Re-run</button>
          <button id="closeBtn" class="btn" type="button">Close</button>
        </div>
      </div>

      <!-- status / errors -->
      <div class="status-line">
        <div id="inlineLoader" class="inline-load" style="display:none;">
          <span id="inlineStatus">Loading emulator…</span>
          <progress id="inlineProg" value="0" max="100"></progress>
          <span id="inlineText"></span>
        </div>
        <div id="inlineReady" style="display:none;">Ready.</div>
      </div>
      <div id="inlineError" class="error-line"></div>

      <div id="dosbox" aria-label="DOSBox frame"></div>
    </div>
  </div>

  <script>
  (function(){
    console.log('[init] page script start');

    // --- CodeMirror
    const cm = CodeMirror.fromTextArea(document.getElementById('editorTA'), {
      lineNumbers: true, mode: 'text/x-gas', indentUnit: 2, tabSize: 2, indentWithTabs: false,
    });

    // --- Elements
    const runBtn = document.getElementById('runBtn');
    const fileNameEl = document.getElementById('fileName');
    const overlay = document.getElementById('overlay');
    const closeBtn = document.getElementById('closeBtn');
    const rerunBtn = document.getElementById('rerunBtn');
    const elDos = document.getElementById('dosbox');
    const bgPrep = document.getElementById('bgPrep');

    const inlineLoader = document.getElementById('inlineLoader');
    const inlineStatus = document.getElementById('inlineStatus');
    const inlineProg = document.getElementById('inlineProg');
    const inlineText = document.getElementById('inlineText');
    const inlineReady = document.getElementById('inlineReady');
    const inlineError = document.getElementById('inlineError');

    const encoder = new TextEncoder();
    let player = null;
    let preloadDone = false;
    let toolBufs = new Map(); // DOS filename -> Uint8Array
    const CACHE_NAME = 'dosbox-prewarm-v6';

    const toDos83 = (name)=>{
      const i = name.lastIndexOf('.');
      let b = (i>=0?name.slice(0,i):name).toUpperCase();
      let e = (i>=0?name.slice(i+1):'').toUpperCase();
      const clean = s=>s.replace(/[^A-Z0-9]/g,'_');
      b = clean(b).slice(0,8); e = clean(e).slice(0,3);
      return e?`${b}.${e}`:b;
    };

    const DOS_CONF = `
[sdl]
fullscreen=false

[autoexec]
@echo off
mount c .
c:
cls
BUILD
`;

    function buildBatFor(dosAsmName){
      const base = dosAsmName.replace(/\.[^.]*$/,'');
      const lines = [
        '@echo off',
        'echo Assembling ' + dosAsmName,
        'TASM /zi /q ' + dosAsmName,
        'if errorlevel 1 goto ERR',
        'echo Linking ' + base + '.OBJ',
        'TLINK /v ' + base + '.OBJ,,NUL,;',
        'if errorlevel 1 goto ERR',
        'echo Running ' + base + '.EXE',
        base + '.EXE',
        'echo.',
        'goto END',
        ':ERR',
        'echo Build failed.',
        ':END'
      ];
      return encoder.encode(lines.join("\r\n") + "\r\n");
    }

    function startDosWith(initFs){
      console.log('[dos] startDosWith initFs entries:', initFs.length);
      if (player && typeof player.exit === 'function') { try { player.exit(); } catch {} }
      elDos.innerHTML = '';
      if (!window.Dos) {
        throw new Error('js-dos not loaded (window.Dos is undefined)');
      }
      player = window.Dos(elDos, {
        pathPrefix: "emulators/",
        dosboxConf: DOS_CONF,
        initFs,
        noCloud: true,
        noNetworking: true,
        kiosk: true,
        autostart: true
      });
    }

    async function waitForCOIController(timeoutMs=7000){
      const t0 = performance.now();
      while (performance.now() - t0 < timeoutMs) {
        if (navigator.serviceWorker?.controller) {
          // Some browsers may take time to set crossOriginIsolated; don’t hard fail immediately.
          if (self.crossOriginIsolated) return;
        }
        await new Promise(r=>setTimeout(r,120));
      }
      // At this point, SW likely not active or COI failed.
      console.warn('[coi] Not crossOriginIsolated yet.');
      // We’ll proceed; js-dos may still work (depending on build). If it fails, we show inline error.
    }

    function openModal(){
      overlay.classList.add('open');
      overlay.setAttribute('aria-hidden','false');
    }
    function closeModal(){
      overlay.classList.remove('open');
      overlay.setAttribute('aria-hidden','true');
    }

    function showInlineLoader(label, done, total){
      inlineError.classList.remove('show');
      inlineReady.style.display = 'none';
      inlineLoader.style.display = 'flex';
      inlineStatus.textContent = label || 'Loading…';
      if (typeof done === 'number' && typeof total === 'number') {
        inlineProg.max = total; inlineProg.value = done; inlineText.textContent = `${done}/${total}`;
      } else {
        inlineText.textContent = '';
      }
    }
    function hideInlineLoaderShowReady(){
      inlineLoader.style.display = 'none';
      inlineError.classList.remove('show');
      inlineReady.style.display = 'block';
      inlineReady.textContent = 'Ready.';
    }
    function showInlineError(msg){
      inlineLoader.style.display = 'none';
      inlineReady.style.display = 'none';
      inlineError.textContent = 'Error: ' + msg;
      inlineError.classList.add('show');
    }

    // Background preloader (silent text line updates only)
    async function backgroundPreload() {
      console.log('[preload] background start');
      try {
        await waitForCOIController().catch(()=>{});
        const files = [
          { path:'emulators/wdosbox.wasm', url:'emulators/wdosbox.wasm', required:true,  keepInMemory:false },
          { path:'emulators/wdosbox.js',   url:'emulators/wdosbox.js',   required:false, keepInMemory:false },
          { path:'TASM.EXE',     url:'tools/TASM.EXE',     required:true,  keepInMemory:true },
          { path:'TLINK.EXE',    url:'tools/TLINK.EXE',    required:true,  keepInMemory:true },
          { path:'DPMI16BI.OVL', url:'tools/DPMI16BI.OVL', required:false, keepInMemory:true },
          { path:'RTM.EXE',      url:'tools/RTM.EXE',      required:false, keepInMemory:true },
          { path:'TD.EXE',       url:'tools/TD.EXE',       required:false, keepInMemory:true },
          { path:'TDCONFIG.TD',  url:'tools/TDCONFIG.TD',  required:false, keepInMemory:true },
        ];
        const cache = await caches.open(CACHE_NAME);
        const mem = new Map();

        // Cache hits -> fill memory for tools
        for (const f of files) {
          const hit = await cache.match(f.url);
          if (hit && f.keepInMemory) {
            const buf = new Uint8Array(await hit.clone().arrayBuffer());
            mem.set(f.path, buf);
          }
        }
        // Fetch misses
        for (const f of files) {
          const hit = await cache.match(f.url);
          if (hit) continue;
          const resp = await fetch(new Request(f.url, { cache:'reload' })).catch(()=>null);
          if (resp && resp.ok) {
            cache.put(f.url, resp.clone()).catch(()=>{});
            if (f.keepInMemory) {
              const buf = new Uint8Array(await resp.clone().arrayBuffer());
              mem.set(f.path, buf);
            }
          }
        }
        // Ensure memory has all wanted tools (from hits)
        for (const f of files) {
          if (!f.keepInMemory || mem.has(f.path)) continue;
          const hit = await cache.match(f.url);
          if (hit) {
            const buf = new Uint8Array(await hit.clone().arrayBuffer());
            mem.set(f.path, buf);
          }
        }
        toolBufs = new Map();
        for (const [k,v] of mem.entries()){
          toolBufs.set(k.split('/').pop(), v);
        }
        preloadDone = true;
        bgPrep.textContent = 'Emulator prepared.';
        console.log('[preload] background complete');
      } catch (e) {
        console.warn('[preload] background failed:', e);
        // continue; foreground will handle on demand
      }
    }

    // Foreground preload with visible progress if needed
    async function ensurePreloadedInline(){
      if (preloadDone) { hideInlineLoaderShowReady(); return; }

      const files = [
        { path:'emulators/wdosbox.wasm', url:'emulators/wdosbox.wasm', required:true,  keepInMemory:false },
        { path:'emulators/wdosbox.js',   url:'emulators/wdosbox.js',   required:false, keepInMemory:false },
        { path:'TASM.EXE',     url:'tools/TASM.EXE',     required:true,  keepInMemory:true },
        { path:'TLINK.EXE',    url:'tools/TLINK.EXE',    required:true,  keepInMemory:true },
        { path:'DPMI16BI.OVL', url:'tools/DPMI16BI.OVL', required:false, keepInMemory:true },
        { path:'RTM.EXE',      url:'tools/RTM.EXE',      required:false, keepInMemory:true },
        { path:'TD.EXE',       url:'tools/TD.EXE',       required:false, keepInMemory:true },
        { path:'TDCONFIG.TD',  url:'tools/TDCONFIG.TD',  required:false, keepInMemory:true },
      ];
      const cache = await caches.open(CACHE_NAME);
      const mem = new Map();

      let total = files.length, done = 0;
      showInlineLoader('Preparing emulator…', done, total);

      // hits
      for (const f of files) {
        const hit = await cache.match(f.url);
        if (hit) {
          done++; showInlineLoader('Preparing emulator…', done, total);
          if (f.keepInMemory) {
            const buf = new Uint8Array(await hit.clone().arrayBuffer());
            mem.set(f.path, buf);
          }
        }
      }
      // misses
      for (const f of files) {
        const hit = await cache.match(f.url);
        if (hit) continue;
        const resp = await fetch(new Request(f.url, { cache:'reload' })).catch(()=>null);
        if (!resp || !resp.ok) {
          if (f.required) { showInlineError('Network error loading required files.'); throw new Error('required'); }
        } else {
          cache.put(f.url, resp.clone()).catch(()=>{});
          if (f.keepInMemory) {
            const buf = new Uint8Array(await resp.clone().arrayBuffer());
            mem.set(f.path, buf);
          }
        }
        done++; showInlineLoader('Preparing emulator…', done, total);
      }
      // fill mem from hits if needed
      for (const f of files) {
        if (!f.keepInMemory || mem.has(f.path)) continue;
        const hit = await cache.match(f.url);
        if (hit) {
          const buf = new Uint8Array(await hit.clone().arrayBuffer());
          mem.set(f.path, buf);
        }
      }
      toolBufs = new Map();
      for (const [k,v] of mem.entries()){
        toolBufs.set(k.split('/').pop(), v);
      }
      preloadDone = true;
      hideInlineLoaderShowReady();
    }

    async function runCurrentBuffer(){
      try {
        await waitForCOIController().catch(()=>{});
        await ensurePreloadedInline();

        const nm = (fileNameEl.value || 'HELLO.ASM').trim();
        const dosAsmName = toDos83(nm);
        const asmBytes = new TextEncoder().encode(cm.getValue());

        const initFs = [
          { path: 'TASM.EXE',  contents: toolBufs.get('TASM.EXE') },
          { path: 'TLINK.EXE', contents: toolBufs.get('TLINK.EXE') },
          { path: dosAsmName,  contents: asmBytes },
          { path: 'BUILD.BAT', contents: buildBatFor(dosAsmName) },
        ];
        for (const p of ['DPMI16BI.OVL','RTM.EXE','TD.EXE','TDCONFIG.TD']) {
          const buf = toolBufs.get(p); if (buf) initFs.push({ path: p, contents: buf });
        }

        startDosWith(initFs);
      } catch (e) {
        console.error('[run] failed:', e);
        showInlineError(e && e.message ? e.message : String(e));
      }
    }

    // Wire up
    runBtn.addEventListener('click', ()=>{
      openModal();
      // show loader immediately (prevents “just dark overlay”)
      showInlineLoader('Preparing emulator…');
      setTimeout(()=>{ runCurrentBuffer(); }, 0);
    });
    rerunBtn.addEventListener('click', ()=>{ showInlineLoader('Rebuilding…'); runCurrentBuffer(); });
    closeBtn.addEventListener('click', ()=>{ closeModal(); });

    // Background prep
    backgroundPreload();
  })();
  </script>
</body>
</html>
