<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DOSBox Emulator</title>

  <!-- Prioritize heavy emulator assets -->
  <link rel="preload" as="fetch" href="emulators/wdosbox.wasm" type="application/wasm" crossorigin>
  <link rel="preload" as="script" href="emulators/wdosbox.js">

  <link rel="stylesheet" href="js-dos.css" />
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: #fff; color: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: grid; place-items: start center;
    }
    main { width: 100%; max-width: 960px; padding: 16px; }
    h1 { margin: 0 0 12px 0; font-size: 20px; font-weight: 600; }

    /* Loading screen */
    #loading { margin: 8px 0 12px; }
    #status { font-size: 13px; color: #374151; margin-bottom: 6px; }
    #progWrap { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    progress { width: 260px; height: 14px; }

    /* App (hidden until ready) */
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    #dosbox { width: 100%; max-width: 896px; aspect-ratio: 1050/600; border: 1px solid #e5e7eb; background: #000; }
    button, label.file {
      font: inherit; font-size: 14px; padding: 10px 14px; border-radius: 8px;
      border: 1px solid #e5e7eb; background: #f8fafc; color: #111; cursor: pointer;
    }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    label.file{ position:relative; }
    label.file input[type=file]{ position:absolute; inset:0; opacity:0; cursor:pointer; }
    ul { margin: 8px 0 0; padding-left: 18px; }
    .hidden { display: none !important; }
  </style>

  <!-- Register COI SW early; page reloads once when SW is ready -->
  <script>
  (function registerCOI() {
    if (!('serviceWorker' in navigator)) return;
    const swUrl = new URL('./coi-sw.js', location.href);
    const KEY = 'coi-reloaded-once';
    navigator.serviceWorker.register(swUrl, { scope: './' }).then(async () => {
      if (!navigator.serviceWorker.controller && !sessionStorage.getItem(KEY)) {
        try { await navigator.serviceWorker.ready; sessionStorage.setItem(KEY,'1'); location.reload(); } catch {}
      }
    });
    navigator.serviceWorker.addEventListener('controllerchange', () => { sessionStorage.removeItem(KEY); });
  })();
  </script>

  <!-- js-dos (local UMD build) -->
  <script src="js-dos.js"></script>
</head>
<body>
  <main>
    <h1>DOSBox Emulator</h1>

    <!-- Loading screen -->
    <section id="loading">
      <div id="status">Preparing…</div>
      <div id="progWrap" class="hidden">
        <progress id="prog" value="0" max="100"></progress>
        <span id="progText"></span>
      </div>
    </section>

    <!-- App UI (hidden until ready) -->
    <section id="app" class="hidden" aria-hidden="true">
      <div class="row" id="controls">
        <label class="file">Choose files<input id="fileInput" type="file" multiple /></label>
        <button id="startBtn" disabled>Start</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div id="dosbox"></div>
      <ul id="fileList" class="hidden"></ul>
    </section>
  </main>

  <script>
  (function(){
    const DosGlobal = window.Dos;

    // Elements
    const elApp = document.getElementById('app');
    const elDos = document.getElementById('dosbox');
    const elInput = document.getElementById('fileInput');
    const elList = document.getElementById('fileList');
    const elStart = document.getElementById('startBtn');
    const elReset = document.getElementById('resetBtn');
    const elLoading = document.getElementById('loading');
    const elStatus = document.getElementById('status');
    const elProgWrap = document.getElementById('progWrap');
    const elProg = document.getElementById('prog');
    const elProgText = document.getElementById('progText');

    const encoder = new TextEncoder();
    let player = null;    // js-dos player
    let ci = null;        // command interface after warm boot
    let ready = false;
    let toolBufs = new Map(); // filename -> Uint8Array

    // ---------- COI gate ----------
    async function waitForCOIController(timeoutMs=8000){
      const t0 = performance.now();
      if (navigator.serviceWorker?.controller && self.crossOriginIsolated) return;
      while (performance.now() - t0 < timeoutMs) {
        if (navigator.serviceWorker?.controller && self.crossOriginIsolated) return;
        await new Promise(r=>setTimeout(r,100));
      }
      if (navigator.serviceWorker?.controller && !self.crossOriginIsolated) location.reload();
      throw new Error('Cross-origin isolation not ready');
    }

    // ---------- Preload (single file-count bar: WASM + all tools) ----------
    const CACHE_NAME = 'dosbox-prewarm-v4';

    async function preloadAllWithFileCount(files, label){
      elProgWrap.classList.remove('hidden');
      let total = files.length, done = 0;
      elProg.max = total; elProg.value = 0;
      elProgText.textContent = `${label} (0/${total})`;

      const cache = await caches.open(CACHE_NAME);
      const mem = new Map();

      // pass 1: cache hits
      for (const f of files){
        const hit = await cache.match(f.url);
        if (hit){
          done++;
          elProg.value = done; elProgText.textContent = `${label} (${done}/${total})`;
          if (f.keepInMemory){
            const buf = new Uint8Array(await hit.clone().arrayBuffer());
            mem.set(f.path, buf);
          }
        }
      }
      // pass 2: fetch misses
      for (const f of files){
        const hit = await cache.match(f.url);
        if (hit) continue;

        const req = new Request(f.url, { cache:'reload' });
        const resp = await fetch(req);
        if (!resp.ok){
          if (f.required) throw new Error('Required file failed: ' + f.url);
        } else {
          cache.put(req, resp.clone()).catch(()=>{});
          if (f.keepInMemory){
            const buf = new Uint8Array(await resp.clone().arrayBuffer());
            mem.set(f.path, buf);
          }
        }
        done++;
        elProg.value = done; elProgText.textContent = `${label} (${done}/${total})`;
      }
      // fill in-memory from cache for earlier hits
      for (const f of files){
        if (!f.keepInMemory || mem.has(f.path)) continue;
        const hit = await cache.match(f.url);
        if (hit){
          const buf = new Uint8Array(await hit.clone().arrayBuffer());
          mem.set(f.path, buf);
        }
      }
      elProg.value = total; elProgText.textContent = `${label} complete`;
      return mem;
    }

    // ---------- DOS config / warm boot ----------
    const DOS_CONF_IDLE = `
[autoexec]
@echo off
mount c .
c:
cls
echo Waiting for Start...
:loop
if exist GO.TXT goto run
goto loop
:run
del GO.TXT
CALL BUILD.BAT
`;

    function buildBatFor(dosAsmName){
      const base = dosAsmName.replace(/\.[^.]*$/,'');
      const lines = [
        '@echo off',
        'echo Assembling ' + dosAsmName,
        'TASM /zi /q ' + dosAsmName,
        'if errorlevel 1 goto ERR',
        'echo Linking ' + base + '.OBJ',
        'TLINK /v ' + base + '.OBJ,,NUL,;',
        'if errorlevel 1 goto ERR',
        'echo Running ' + base + '.EXE',
        base + '.EXE',
        'echo.',
        'goto END',
        ':ERR',
        'echo Build failed.',
        ':END'
      ];
      return encoder.encode(lines.join("\r\n") + "\r\n");
    }

    function warmBoot(){
      if (player && typeof player.exit==='function'){ try { player.exit(); } catch{} }
      elDos.innerHTML = '';
      player = DosGlobal(elDos, {
        pathPrefix: "emulators/",
        dosboxConf: DOS_CONF_IDLE,
        noCloud: true,
        noNetworking: true,
        kiosk: true,
        autostart: true,
        onEvent: (ev, arg) => { if (ev === "ci-ready") ci = arg; }
      });
    }

    // ---------- File helpers / UI ----------
    const toDos83 = (name)=>{
      const i = name.lastIndexOf('.');
      let b = (i>=0?name.slice(0,i):name).toUpperCase();
      let e = (i>=0?name.slice(i+1):'').toUpperCase();
      const clean = s=>s.replace(/[^A-Z0-9]/g,'_');
      b = clean(b).slice(0,8); e = clean(e).slice(0,3);
      return e?`${b}.${e}`:b;
    };
    const isAsm = n => /\.asm$/i.test(n);
    const bag = new Map();
    const countAsm = it => Array.from(it).filter(f => isAsm(f.name)).length;

    function refresh(){
      const files = Array.from(bag.values());
      elList.innerHTML = '';
      for (const f of files){
        const li = document.createElement('li');
        li.textContent = `${f.name} → ${toDos83(f.name)}`;
        elList.appendChild(li);
      }
      if (files.length) elList.classList.remove('hidden');
      elStart.disabled = !(ready && countAsm(files) === 1);
    }
    function addFiles(list){
      const incoming = Array.from(list || []);
      const existingAsm = countAsm(bag.values());
      let toAddAsm = 0; for (const f of incoming) if (isAsm(f.name)) toAddAsm++;
      if (existingAsm + toAddAsm > 1) alert('Select exactly ONE .asm file. Extra .asm files were ignored.');
      for (const f of incoming){ if (isAsm(f.name) && existingAsm>=1) continue; bag.set(f.name,f); }
      refresh();
    }

    // ---------- Wire up ----------
    elInput.addEventListener('change', ()=>{ addFiles(elInput.files); elInput.value=''; });
    elReset.addEventListener('click', ()=>location.reload());
    elStart.addEventListener('click', async ()=>{
      try{
        elStart.disabled = true;
        const files = Array.from(bag.values());
        const asmFiles = files.filter(f => isAsm(f.name));
        if (asmFiles.length !== 1) return;

        const asmText = await asmFiles[0].text();
        const dosAsmName = toDos83(asmFiles[0].name);
        if (!ci) { alert('Emulator not ready yet.'); elStart.disabled = false; return; }

        // Write tools into live FS (from memory buffers)
        const required = ['TASM.EXE','TLINK.EXE'];
        for (const p of required) {
          const buf = toolBufs.get(p); if (buf) await ci.fsWriteFile(p, buf);
        }
        const optional = ['DPMI16BI.OVL','RTM.EXE','TD.EXE','TDCONFIG.TD'];
        for (const p of optional) {
          const buf = toolBufs.get(p); if (buf) await ci.fsWriteFile(p, buf);
        }

        // Write user files
        await ci.fsWriteFile(dosAsmName, encoder.encode(asmText));
        for (const f of files){
          if (f === asmFiles[0]) continue;
          const buf = new Uint8Array(await f.arrayBuffer());
          await ci.fsWriteFile(toDos83(f.name), buf);
        }

        // Write BUILD.BAT and trigger the waiting AUTOEXEC
        await ci.fsWriteFile('BUILD.BAT', buildBatFor(dosAsmName));
        await ci.fsWriteFile('GO.TXT', new Uint8Array());
      } catch(e){
        console.error(e);
        alert('Error. See console.');
        elStart.disabled = false;
      }
    });

    // ---------- Boot sequence ----------
    (async()=>{
      try{
        elStatus.textContent = 'Waiting for site control…';
        await waitForCOIController();

        // One combined list (WASM + tools) with file-count progress
        const preloadList = [
          { path:'emulators/wdosbox.wasm', url:'emulators/wdosbox.wasm', required:true,  keepInMemory:false },
          { path:'emulators/wdosbox.js',   url:'emulators/wdosbox.js',   required:false, keepInMemory:false },
          { path:'TASM.EXE',     url:'tools/TASM.EXE',     required:true,  keepInMemory:true },
          { path:'TLINK.EXE',    url:'tools/TLINK.EXE',    required:true,  keepInMemory:true },
          { path:'DPMI16BI.OVL', url:'tools/DPMI16BI.OVL', required:false, keepInMemory:true },
          { path:'RTM.EXE',      url:'tools/RTM.EXE',      required:false, keepInMemory:true },
          { path:'TD.EXE',       url:'tools/TD.EXE',       required:false, keepInMemory:true },
          { path:'TDCONFIG.TD',  url:'tools/TDCONFIG.TD',  required:false, keepInMemory:true }
        ];
        elStatus.textContent = 'Loading emulator and tools…';
        const mem = await preloadAllWithFileCount(preloadList, 'Loading emulator and tools');
        // Store to toolBufs using only DOS filenames
        toolBufs = new Map();
        for (const [k,v] of mem.entries()){
          const name = k.split('/').pop();
          toolBufs.set(name, v);
        }

        // Warm-boot emulator so Start is instant
        elStatus.textContent = 'Starting emulator…';
        warmBoot();

        // Show UI
        ready = true;
        elApp.classList.remove('hidden'); elApp.setAttribute('aria-hidden','false');
        elLoading.classList.add('hidden');
        refresh();
      }catch(e){
        console.error(e);
        elStatus.textContent = 'Could not enable required features. Service workers may be blocked.';
      }
    })();
  })();
  </script>
</body>
</html>
