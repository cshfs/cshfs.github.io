<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DOSBox Emulator</title>

  <!-- Cross-origin isolation via SW (must be same-origin, unbundled) -->
  <script src="coi-serviceworker.js"></script>

  <!-- js-dos UMD build -->
  <link rel="stylesheet" href="js-dos.css" />
  <script src="js-dos.js"></script>

  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #fff; color: #111; display: grid; place-items: start center;
    }
    .page { width: 100%; max-width: 960px; padding: 16px; }
    h1 { margin: 0 0 12px 0; font-size: 20px; font-weight: 600; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    #dosbox {
      width: 100%; max-width: 896px; aspect-ratio: 1050 / 600;
      border: 1px solid #e5e7eb; background: #000;
    }
    button, label.file {
      font: inherit; font-size: 14px; padding: 10px 14px; border-radius: 8px;
      border: 1px solid #e5e7eb; background: #f8fafc; color: #111; cursor: pointer;
    }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    label.file { position: relative; }
    label.file input[type=file] { position:absolute; inset:0; opacity:0; cursor:pointer; }
    ul { margin: 8px 0 0 0; padding-left: 18px; }
    #status { font-size: 13px; color: #374151; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <main class="page">
    <h1>DOSBox Emulator</h1>

    <div id="status">Checking environment…</div>

    <div class="row" id="controls" aria-label="Controls">
      <label class="file" aria-label="Choose files">
        Choose files<input id="fileInput" type="file" multiple />
      </label>

      <button id="startBtn" disabled title="Start after adding exactly one .asm">Start</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div id="dosbox" aria-label="DOSBox frame"></div>
    <ul id="fileList" class="hidden" aria-label="Selected files"></ul>
  </main>

  <script>
  (function () {
    const DosGlobal = window.Dos;
    const elDos   = document.getElementById('dosbox');
    const elInput = document.getElementById('fileInput');
    const elList  = document.getElementById('fileList');
    const elStart = document.getElementById('startBtn');
    const elReset = document.getElementById('resetBtn');
    const elStatus= document.getElementById('status');

    const encoder = new TextEncoder();
    let player = null;

    // --- Requirements gating -------------------------------------------------
    // We wait until:
    //   1) the COI service worker controls this page
    //   2) crossOriginIsolated === true
    // This prevents first-load races on slow networks.
    async function waitForCOIController(timeoutMs = 8000) {
      const start = performance.now();
      // If already controlled and isolated, return immediately.
      if (navigator.serviceWorker?.controller && self.crossOriginIsolated) return;

      // Poll for controller and isolation; the COI SW will auto-reload once.
      while (performance.now() - start < timeoutMs) {
        if (navigator.serviceWorker?.controller && self.crossOriginIsolated) return;
        await new Promise(r => setTimeout(r, 100));
      }
      // If we got controller but not CIO, give one programmatic reload.
      if (navigator.serviceWorker?.controller && !self.crossOriginIsolated) {
        location.reload();
      }
      throw new Error('Cross-origin isolation not ready');
    }

    // --- Helpers -------------------------------------------------------------
    function toDos83(name) {
      const i = name.lastIndexOf('.');
      let base = (i >= 0 ? name.slice(0, i) : name).toUpperCase();
      let ext  = (i >= 0 ? name.slice(i + 1) : '').toUpperCase();
      const clean = s => s.replace(/[^A-Z0-9]/g, '_');
      base = clean(base).slice(0, 8);
      ext  = clean(ext).slice(0, 3);
      return ext ? `${base}.${ext}` : base;
    }
    function isAsm(name){
      if (!name) return false;
      const n = String(name).toLowerCase().trim().replace(/[\.]+$/,'');
      return n.endsWith('.asm');
    }

    // --- Tool buffers --------------------------------------------------------
    let tasmBuf=null, tlinkBuf=null, dpmiBuf=null, rtmBuf=null, tdBuf=null, tdCfgBuf=null;
    async function preloadTools(){
      const get = async (path, opt=false) => {
        const r = await fetch(path);
        if (!r.ok) { if (opt) return null; throw new Error(path + ' not found'); }
        return new Uint8Array(await r.arrayBuffer());
      };
      [tasmBuf, tlinkBuf, dpmiBuf, rtmBuf, tdBuf, tdCfgBuf] = await Promise.all([
        get('tools/TASM.EXE'),
        get('tools/TLINK.EXE'),
        get('tools/DPMI16BI.OVL', true),
        get('tools/RTM.EXE',     true),
        get('tools/TD.EXE',      true),
        get('tools/TDCONFIG.TD', true)
      ]);
    }

    // --- DOS config ----------------------------------------------------------
    const DOS_CONF = `
[sdl]
fullscreen=false

[autoexec]
@echo off
mount c .
c:
cls
BUILD
`;

    function buildBatFor(dosAsmName){
      const base = dosAsmName.replace(/\.[^.]*$/, '');
      const lines = [
        '@echo off',
        'TASM /zi /q ' + dosAsmName + ' > BUILD.LOG',
        'if errorlevel 1 goto ERR',
        'TLINK /v ' + base + '.OBJ,,NUL,; >> BUILD.LOG',
        'if errorlevel 1 goto ERR',
        base + '.EXE',
        'echo.',
        'goto END',
        ':ERR',
        'type BUILD.LOG',
        ':END'
      ];
      return encoder.encode(lines.join("\\r\\n") + "\\r\\n");
    }

    function startDosWith(initFs){
      if (player && typeof player.exit === 'function') { try { player.exit(); } catch {} }
      elDos.innerHTML = '';
      player = DosGlobal(elDos, {
        pathPrefix: "emulators/",
        dosboxConf: DOS_CONF,
        initFs,
        noCloud: true,
        noNetworking: true,
        kiosk: true,
        autostart: true
      });
    }

    // --- File bag ------------------------------------------------------------
    const bag = new Map(); // name -> File
    const countAsm = it => Array.from(it).filter(f => isAsm(f.name)).length;

    function refresh(){
      const files = Array.from(bag.values());
      elList.innerHTML = '';
      for (const f of files) {
        const li = document.createElement('li');
        li.textContent = `${f.name} → ${toDos83(f.name)}`;
        elList.appendChild(li);
      }
      if (files.length) elList.classList.remove('hidden');
      elStart.disabled = !(ready && countAsm(files) === 1);
    }

    function addFiles(list){
      const incoming = Array.from(list || []);
      const existingAsm = countAsm(bag.values());
      let toAddAsm = 0;
      for (const f of incoming) if (isAsm(f.name)) toAddAsm++;
      if (existingAsm + toAddAsm > 1) { alert('Select exactly ONE .asm file. Extra .asm files were ignored.'); }
      for (const f of incoming) {
        if (isAsm(f.name) && existingAsm >= 1) continue;
        bag.set(f.name, f);
      }
      refresh();
    }

    async function bagToInitFs(){
      const files = Array.from(bag.values());
      const asmFiles = files.filter(f => isAsm(f.name));
      if (asmFiles.length !== 1) throw new Error('Invalid ASM selection');
      if (!tasmBuf || !tlinkBuf) await preloadTools();

      const asmText = await asmFiles[0].text();
      const dosAsmName = toDos83(asmFiles[0].name);

      const initFs = [
        { path: 'TASM.EXE',  contents: tasmBuf },
        { path: 'TLINK.EXE', contents: tlinkBuf },
        { path: dosAsmName,  contents: encoder.encode(asmText) },
        { path: 'BUILD.BAT', contents: buildBatFor(dosAsmName) }
      ];
      if (dpmiBuf)  initFs.push({ path: 'DPMI16BI.OVL', contents: dpmiBuf });
      if (rtmBuf)   initFs.push({ path: 'RTM.EXE',      contents: rtmBuf  });
      if (tdBuf)    initFs.push({ path: 'TD.EXE',       contents: tdBuf   });
      if (tdCfgBuf) initFs.push({ path: 'TDCONFIG.TD',  contents: tdCfgBuf});

      for (const f of files) {
        if (f === asmFiles[0]) continue;
        const buf = new Uint8Array(await f.arrayBuffer());
        initFs.push({ path: toDos83(f.name), contents: buf });
      }
      return initFs;
    }

    // --- Wire up UI ----------------------------------------------------------
    elInput.addEventListener('change', () => { addFiles(elInput.files); elInput.value = ''; });
    elStart.addEventListener('click', async () => {
      try {
        elStart.disabled = true;
        elStatus.textContent = 'Preparing DOSBox…';
        const initFs = await bagToInitFs();
        startDosWith(initFs);
        elStatus.textContent = 'Running.';
      } catch (e) {
        console.error(e);
        elStatus.textContent = 'Error. See console.';
        elStart.disabled = false;
      }
    });
    elReset.addEventListener('click', () => location.reload());

    // --- Boot sequence -------------------------------------------------------
    let ready = false;
    (async () => {
      try {
        elStatus.textContent = 'Enabling cross-origin isolation…';
        await waitForCOIController(); // guarantees crossOriginIsolated true or throws
        elStatus.textContent = 'Loading tools…';
        await preloadTools();         // warm cache on first visit, resilient to slow Wi-Fi
        ready = true;
        elStatus.textContent = 'Ready. Add exactly one .asm and click Start.';
        refresh();
      } catch (e) {
        console.error(e);
        elStatus.textContent = 'Could not enable required features. Check that service workers are allowed.';
      }
    })();
  })();
  </script>
</body>
</html>
