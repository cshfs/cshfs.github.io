<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DOSBox Emulator</title>

  <link rel="stylesheet" href="js-dos.css" />
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: #fff; color: #111; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; display: grid; place-items: start center; }
    main { width: 100%; max-width: 960px; padding: 16px; }
    h1 { margin: 0 0 12px 0; font-size: 20px; font-weight: 600; }

    /* Loading screen */
    #loading { margin: 8px 0 12px; }
    #status { font-size: 13px; color: #374151; margin-bottom: 6px; }
    #progWrap { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    progress { width: 260px; height: 14px; }

    /* App UI (hidden until ready) */
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    #dosbox { width: 100%; max-width: 896px; aspect-ratio: 1050 / 600; border: 1px solid #e5e7eb; background: #000; }
    button, label.file { font: inherit; font-size: 14px; padding: 10px 14px; border-radius: 8px; border: 1px solid #e5e7eb; background: #f8fafc; color: #111; cursor: pointer; }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    label.file { position: relative; }
    label.file input[type=file] { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
    ul { margin: 8px 0 0 0; padding-left: 18px; }
    .hidden { display: none !important; }
  </style>

  <!-- Register SW early; page reloads once when SW is ready -->
  <script>
  (function registerCOI() {
    if (!('serviceWorker' in navigator)) return;
    const swUrl = new URL('./coi-sw.js', location.href);
    const KEY = 'coi-reloaded-once';
    navigator.serviceWorker.register(swUrl, { scope: './' }).then(async () => {
      if (!navigator.serviceWorker.controller && !sessionStorage.getItem(KEY)) {
        try { await navigator.serviceWorker.ready; sessionStorage.setItem(KEY, '1'); location.reload(); } catch {}
      }
    });
    navigator.serviceWorker.addEventListener('controllerchange', () => { sessionStorage.removeItem(KEY); });
  })();
  </script>

  <script src="js-dos.js"></script>
</head>
<body>
  <main>
    <h1>DOSBox Emulator</h1>

    <!-- Loading screen -->
    <section id="loading">
      <div id="status">Enabling required features…</div>
      <div id="progWrap" class="hidden">
        <progress id="prog" value="0"></progress>
        <span id="progText"></span>
      </div>
    </section>

    <!-- App UI (hidden until ready) -->
    <section id="app" class="hidden" aria-hidden="true">
      <div class="row" id="controls">
        <label class="file">Choose files<input id="fileInput" type="file" multiple /></label>
        <button id="startBtn" disabled>Start</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div id="dosbox"></div>
      <ul id="fileList" class="hidden"></ul>
    </section>
  </main>

  <script>
  (function () {
    const DosGlobal = window.Dos;

    // Elements
    const elApp   = document.getElementById('app');
    const elDos   = document.getElementById('dosbox');
    const elInput = document.getElementById('fileInput');
    const elList  = document.getElementById('fileList');
    const elStart = document.getElementById('startBtn');
    const elReset = document.getElementById('resetBtn');
    const elLoading  = document.getElementById('loading');
    const elStatus   = document.getElementById('status');
    const elProgWrap = document.getElementById('progWrap');
    const elProg     = document.getElementById('prog');
    const elProgText = document.getElementById('progText');

    const encoder = new TextEncoder();
    let player = null;
    let ready = false;

    // Gate: SW control + COI
    async function waitForCOIController(timeoutMs = 8000) {
      const t0 = performance.now();
      if (navigator.serviceWorker?.controller && self.crossOriginIsolated) return;
      while (performance.now() - t0 < timeoutMs) {
        if (navigator.serviceWorker?.controller && self.crossOriginIsolated) return;
        await new Promise(r => setTimeout(r, 100));
      }
      if (navigator.serviceWorker?.controller && !self.crossOriginIsolated) location.reload();
      throw new Error('Cross-origin isolation not ready');
    }

    // Cache
    const CACHE_NAME = 'dosbox-prewarm-v1';

    // Stream a URL into Cache and memory with byte progress
    async function streamToMemoryAndCache(url, label) {
      elProgWrap.classList.remove('hidden');
      elProg.value = 0; elProg.removeAttribute('max');
      elProgText.textContent = `Downloading ${label}…`;

      const req = new Request(url, { cache: 'reload' });
      const resp = await fetch(req);
      if (!resp.ok) throw new Error(`Fetch failed: ${url}`);
      const len = Number(resp.headers.get('Content-Length')) || 0;

      const cache = await caches.open(CACHE_NAME);
      const [forProgress, forCache, forMemory] = (resp.body ? resp.body.tee().concat([]) : []); // placeholder
      // body.tee() returns 2 streams; we need 2 tees total to get 3. Do it in steps:
      let s1, s2, s3;
      if (resp.body) {
        const [a, b] = resp.body.tee();
        const [b1, b2] = b.tee();
        s1 = a; s2 = b1; s3 = b2;
      }

      // Cache write
      const cacheResp = new Response(s2 || resp.body, { status: resp.status, statusText: resp.statusText, headers: resp.headers });
      const putP = cache.put(req, cacheResp);

      // Progress + memory buffer
      let loaded = 0;
      const chunks = [];
      if (s1) {
        if (len > 0) elProg.max = 100;
        const reader = s1.getReader();
        for (;;) {
          const {done, value} = await reader.read();
          if (done) break;
          chunks.push(value);
          loaded += value.byteLength;
          if (len > 0) {
            const pct = Math.min(100, Math.floor((loaded / len) * 100));
            elProg.value = pct;
            elProgText.textContent = `Downloading ${label}… ${pct}%`;
          }
        }
      } else {
        // no stream
        const buf = new Uint8Array(await resp.arrayBuffer());
        chunks.push(buf);
      }

      await putP;

      // Concatenate chunks
      let total = 0; for (const c of chunks) total += c.byteLength;
      const out = new Uint8Array(total);
      let off = 0; for (const c of chunks) { out.set(c, off); off += c.byteLength; }

      elProg.value = 100; elProg.max = 100;
      elProgText.textContent = `${label} ready`;
      return out;
    }

    // Combined byte-progress for multiple files
    async function downloadToolsWithByteProgress(list) {
      // First try cache quick path
      const cache = await caches.open(CACHE_NAME);
      const result = new Map();
      let totalKnown = 0, knownCount = 0;

      // Probe sizes
      const sizes = await Promise.all(list.map(async f => {
        const cached = await cache.match(f.url);
        if (cached) {
          const buf = new Uint8Array(await cached.clone().arrayBuffer());
          result.set(f.path, buf);
          return {url:f.url, size: buf.byteLength, cached:true};
        }
        try {
          const head = await fetch(f.url, { method:'HEAD', cache:'reload' });
          const n = Number(head.headers.get('Content-Length')) || 0;
          if (n > 0) { totalKnown += n; knownCount++; }
          return {url:f.url, size:n, cached:false};
        } catch { return {url:f.url, size:0, cached:false}; }
      }));

      // Download any missing with visible aggregate progress
      let loaded = 0;
      elProgWrap.classList.remove('hidden');
      if (totalKnown > 0) { elProg.max = 100; elProg.value = 0; }
      elProgText.textContent = 'Loading tools…';

      for (const f of list) {
        if (result.has(f.path)) continue;

        const req = new Request(f.url, { cache: 'reload' });
        const resp = await fetch(req);
        if (!resp.ok) { if (f.required) throw new Error('Missing required tool: ' + f.path); else continue; }

        const len = Number(resp.headers.get('Content-Length')) || 0;
        const [forProgress, forCache] = resp.body ? resp.body.tee() : [null, null];

        // Cache
        if (forCache) {
          const cacheResp = new Response(forCache, { status: resp.status, statusText: resp.statusText, headers: resp.headers });
          cache.put(req, cacheResp).catch(() => {});
        }

        // Progress + memory
        let fileLoaded = 0;
        const chunks = [];
        if (forProgress) {
          const reader = forProgress.getReader();
          for (;;) {
            const {done, value} = await reader.read();
            if (done) break;
            chunks.push(value);
            fileLoaded += value.byteLength;
            if (totalKnown > 0 && len > 0) {
              loaded += value.byteLength;
              const pct = Math.min(100, Math.floor((loaded / totalKnown) * 100));
              elProg.value = pct;
              elProgText.textContent = `Loading tools… ${pct}%`;
            }
          }
        } else {
          const buf = new Uint8Array(await resp.arrayBuffer());
          chunks.push(buf);
          if (totalKnown > 0) {
            loaded += buf.byteLength;
            const pct = Math.min(100, Math.floor((loaded / totalKnown) * 100));
            elProg.value = pct;
            elProgText.textContent = `Loading tools… ${pct}%`;
          }
        }
        // concat
        let total = 0; for (const c of chunks) total += c.byteLength;
        const out = new Uint8Array(total);
        let off = 0; for (const c of chunks) { out.set(c, off); off += c.byteLength; }
        result.set(f.path, out);
      }

      elProg.value = 100; elProg.max = 100;
      elProgText.textContent = 'Tools ready';
      return result;
    }

    // DOS config
    const DOS_CONF = `
[sdl]
fullscreen=false

[autoexec]
@echo off
mount c .
c:
cls
BUILD
`;

    function buildBatFor(dosAsmName){
      const base = dosAsmName.replace(/\.[^.]*$/, '');
      const lines = [
        '@echo off',
        'echo Assembling ' + dosAsmName,
        'TASM /zi /q ' + dosAsmName,
        'if errorlevel 1 goto ERR',
        'echo Linking ' + base + '.OBJ',
        'TLINK /v ' + base + '.OBJ,,NUL,;',
        'if errorlevel 1 goto ERR',
        'echo Running ' + base + '.EXE',
        base + '.EXE',
        'echo.',
        'goto END',
        ':ERR',
        'echo Build failed.',
        ':END'
      ];
      return encoder.encode(lines.join("\r\n") + "\r\n");
    }

    function startDosWith(initFs){
      if (player && typeof player.exit === 'function') { try { player.exit(); } catch {} }
      elDos.innerHTML = '';
      player = DosGlobal(elDos, {
        pathPrefix: "emulators/",
        dosboxConf: DOS_CONF,
        initFs,
        noCloud: true,
        noNetworking: true,
        kiosk: true,
        autostart: true
      });
    }

    // File selection
    const bag = new Map();
    const countAsm = it => Array.from(it).filter(f => /\.asm$/i.test(f.name)).length;
    const toDos83 = (name) => {
      const i = name.lastIndexOf('.'); let b=(i>=0?name.slice(0,i):name).toUpperCase(); let e=(i>=0?name.slice(i+1):'').toUpperCase();
      const clean=s=>s.replace(/[^A-Z0-9]/g,'_'); b=clean(b).slice(0,8); e=clean(e).slice(0,3); return e?`${b}.${e}`:b;
    };

    function refresh(){
      const files = Array.from(bag.values());
      elList.innerHTML = '';
      for (const f of files) { const li = document.createElement('li'); li.textContent = `${f.name} → ${toDos83(f.name)}`; elList.appendChild(li); }
      if (files.length) elList.classList.remove('hidden');
      elStart.disabled = !(ready && countAsm(files) === 1);
    }
    function addFiles(list){
      const incoming = Array.from(list || []);
      const existingAsm = countAsm(bag.values());
      let toAddAsm = 0; for (const f of incoming) if (/\.asm$/i.test(f.name)) toAddAsm++;
      if (existingAsm + toAddAsm > 1) alert('Select exactly ONE .asm file. Extra .asm files were ignored.');
      for (const f of incoming) { if (/\.asm$/i.test(f.name) && existingAsm >= 1) continue; bag.set(f.name, f); }
      refresh();
    }

    elInput.addEventListener('change', () => { addFiles(elInput.files); elInput.value = ''; });
    elReset.addEventListener('click', () => location.reload());
    elStart.addEventListener('click', async () => {
      try {
        elStart.disabled = true;
        const files = Array.from(bag.values());
        const asmFiles = files.filter(f => /\.asm$/i.test(f.name));
        if (asmFiles.length !== 1) return;
        const asmText = await asmFiles[0].text();
        const dosAsmName = toDos83(asmFiles[0].name);

        // Use downloaded tool buffers
        const initFs = [
          { path: 'TASM.EXE',  contents: toolBufs.get('TASM.EXE') },
          { path: 'TLINK.EXE', contents: toolBufs.get('TLINK.EXE') },
          { path: dosAsmName,  contents: encoder.encode(asmText) },
          { path: 'BUILD.BAT', contents: buildBatFor(dosAsmName) }
        ];
        // Optional overlays
        if (toolBufs.get('DPMI16BI.OVL')) initFs.push({ path: 'DPMI16BI.OVL', contents: toolBufs.get('DPMI16BI.OVL') });
        if (toolBufs.get('RTM.EXE'))       initFs.push({ path: 'RTM.EXE',      contents: toolBufs.get('RTM.EXE') });
        if (toolBufs.get('TD.EXE'))        initFs.push({ path: 'TD.EXE',       contents: toolBufs.get('TD.EXE') });
        if (toolBufs.get('TDCONFIG.TD'))   initFs.push({ path: 'TDCONFIG.TD',  contents: toolBufs.get('TDCONFIG.TD') });

        // Extra user assets
        for (const f of files) {
          if (f === asmFiles[0]) continue;
          const buf = new Uint8Array(await f.arrayBuffer());
          initFs.push({ path: toDos83(f.name), contents: buf });
        }
        startDosWith(initFs);
      } catch (e) { console.error(e); alert('Error. See console.'); elStart.disabled = false; }
    });

    // Boot
    let toolBufs = new Map();
    (async () => {
      try {
        elStatus.textContent = 'Waiting for site control…';
        await waitForCOIController();

        // Prefetch emulator WASM with byte progress
        elStatus.textContent = 'Downloading emulator…';
        await streamToMemoryAndCache('emulators/wdosbox.wasm', 'emulator (WASM)');
        caches.open(CACHE_NAME).then(async (c) => { try { await c.add('emulators/wdosbox.js'); } catch {} });

        // Download tools with aggregate byte progress
        elStatus.textContent = 'Loading tools…';
        const tools = [
          { path: 'TASM.EXE',     url: 'tools/TASM.EXE',     required: true  },
          { path: 'TLINK.EXE',    url: 'tools/TLINK.EXE',    required: true  },
          { path: 'DPMI16BI.OVL', url: 'tools/DPMI16BI.OVL', required: false },
          { path: 'RTM.EXE',      url: 'tools/RTM.EXE',      required: false },
          { path: 'TD.EXE',       url: 'tools/TD.EXE',       required: false },
          { path: 'TDCONFIG.TD',  url: 'tools/TDCONFIG.TD',  required: false }
        ];
        toolBufs = await downloadToolsWithByteProgress(tools);

        // Ready
        ready = true;
        elApp.classList.remove('hidden');
        elApp.setAttribute('aria-hidden', 'false');
        elLoading.classList.add('hidden');
        refresh();
      } catch (e) {
        console.error(e);
        elStatus.textContent = 'Could not enable required features. Service workers may be blocked.';
      }
    })();
  })();
  </script>
</body>
</html>
