<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>8086 Assembly Runner (Live VM, js-dos v8)</title>

  <!-- js-dos v8 CDN -->
  <link rel="stylesheet" href="https://v8.js-dos.com/latest/js-dos.css">
  <script src="https://v8.js-dos.com/latest/js-dos.js"></script>

  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
    .grid { display: grid; grid-template-columns: 1fr 820px; gap: 16px; align-items: start; }
    textarea { width: 100%; height: 560px; font-family: Consolas, Menlo, monospace; font-size: 14px; }
    #dosbox { width: 800px; height: 600px; border: 1px solid #ccc; }
    #runBtn, #resetBtn { padding: 8px 14px; font-size: 16px; }
    .bar { display:flex; gap:12px; align-items:center; margin:8px 0 0; flex-wrap: wrap; }
    .small { color:#666; font-size: 12px; }
    .uploads { margin-top: 8px; }
    .uploads ul { margin: 6px 0 0; padding-left: 18px; }
    .uploads li { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    h1 { margin-top: 0; }
    .chip { display:inline-block; padding:2px 6px; border:1px solid #ccc; border-radius: 6px; background:#fafafa; }
  </style>
</head>
<body>
  <h1>8086 Assembly Runner</h1>
  <p class="small">
    Paste TASM-style source (<code>.model small</code> etc.), optionally upload files (e.g., <code>TEST.BMP</code>, <code>DATA.TXT</code>), then click <b>Run</b>.
    The emulator stays alive between runs; your program’s generated files remain until you click <b>Reset VM</b>. Your source text is saved locally.
  </p>

  <div class="grid">
    <div>
      <textarea id="code"></textarea>
      <div class="bar">
        <input type="file" id="fileInput" multiple />
        <button id="runBtn">Run</button>
        <button id="resetBtn" title="Recreate a fresh DOS VM (does not clear your editor text)">Reset VM</button>
        <span id="status" class="small"></span>
      </div>

      <div class="uploads">
        <span class="small">Files to inject/overwrite in <span class="chip">C:\</span> (original → DOS 8.3):</span>
        <ul id="fileList"></ul>
      </div>
    </div>

    <div>
      <div id="dosbox"></div>
      <p class="small">
        Tip: refer to uploaded files by their DOS 8.3 names (e.g., <code>TEST.BMP</code>, <code>DATA.TXT</code>).
        Keyboard & mouse work inside the DOS frame—click inside to focus.
      </p>
    </div>
  </div>

  <script>
  if (!window.__asmRunnerInit__) {
    window.__asmRunnerInit__ = true;

    const elCode   = document.getElementById('code');
    const elRun    = document.getElementById('runBtn');
    const elReset  = document.getElementById('resetBtn');
    const elStat   = document.getElementById('status');
    const elDos    = document.getElementById('dosbox');
    const elInput  = document.getElementById('fileInput');
    const elList   = document.getElementById('fileList');

    const LS_KEY = "asm-editor-text-v1";
    const encoder = new TextEncoder();

    const DEFAULT_SRC = [
      "; Sample TASM program (EXE) for 8086",
      ".model small",
      ".stack 100h",
      ".data",
      "msg db 'Hello from TASM in a live VM!$'",
      ".code",
      "main proc",
      "    mov ax, @data",
      "    mov ds, ax",
      "    mov dx, offset msg",
      "    mov ah, 9",
      "    int 21h",
      "    mov ax, 4C00h",
      "    int 21h",
      "main endp",
      "end main"
    ].join("\n");
    elCode.value = localStorage.getItem(LS_KEY) || DEFAULT_SRC;

    // Uploads kept in-memory: { original, dosName, bytes }
    let uploads = [];
    function toDos83(name) {
      const idx = name.lastIndexOf(".");
      let base = (idx >= 0 ? name.slice(0, idx) : name).toUpperCase();
      let ext  = (idx >= 0 ? name.slice(idx + 1) : "").toUpperCase();
      const clean = s => s.replace(/[^A-Z0-9]/g, "_");
      base = clean(base).slice(0, 8);
      ext  = clean(ext).slice(0, 3);
      return ext ? `${base}.${ext}` : base;
    }
    elInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      const reads = files.map(f => new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = () => res({ file: f, bytes: new Uint8Array(r.result) });
        r.onerror = () => rej(r.error || new Error("Read failed: " + f.name));
        r.readAsArrayBuffer(f);
      }));
      try {
        const got = await Promise.all(reads);
        for (const { file, bytes } of got) {
          let dos = toDos83(file.name);
          let candidate = dos, i = 1;
          while (uploads.some(u => u.dosName === candidate)) {
            const dot = dos.lastIndexOf(".");
            const b = dot >= 0 ? dos.slice(0, dot) : dos;
            const e2 = dot >= 0 ? dos.slice(dot) : "";
            const suffix = String(i++).slice(-1);
            candidate = (b.slice(0, Math.max(0, 8 - 1)) + suffix) + e2;
          }
          const idxExisting = uploads.findIndex(u => u.original === file.name);
          if (idxExisting >= 0) uploads[idxExisting] = { original: file.name, dosName: candidate, bytes };
          else uploads.push({ original: file.name, dosName: candidate, bytes });
        }
        elList.innerHTML = "";
        for (const u of uploads) {
          const li = document.createElement("li");
          li.textContent = `${u.original}  →  ${u.dosName}`;
          elList.appendChild(li);
        }
        elStat.textContent = `${uploads.length} file(s) staged`;
      } catch (err) {
        console.error(err);
        elStat.textContent = "Error reading files";
      }
    });

    // Toolchain (fetched once)
    let tasmBuf = null, tlinkBuf = null, dpmiBuf = null, rtmBuf = null;
    async function preloadTools() {
      const get = async (path, opt = false) => {
        const r = await fetch(path);
        if (!r.ok) { if (opt) return null; throw new Error(path + " not found"); }
        return new Uint8Array(await r.arrayBuffer());
      };
      [tasmBuf, tlinkBuf, dpmiBuf, rtmBuf] = await Promise.all([
        get("tools/TASM.EXE"),
        get("tools/TLINK.EXE"),
        get("tools/DPMI16BI.OVL", true),
        get("tools/RTM.EXE", true)
      ]);
    }

    // Start straight in DOS with C: mounted
    const BASIC_CONF = `
[sdl]
fullscreen=false

[autoexec]
@echo off
mount c .
c:
echo Live DOS VM ready
`;

    // v8 Player API
    let props = null; // player
    let ci    = null; // command interface

    function bootVm() {
      return new Promise((resolve) => {
        props = Dos(elDos, {
          dosboxConf: BASIC_CONF,
          onEvent: (event, payload) => {
            if (event === "ci-ready") {
              ci = payload;
              resolve();
            }
          }
        });
      });
    }

    // Helpers
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    async function focusDosCanvas() {
      // Try to focus the canvas so the emulator accepts input
      const canvas = elDos.querySelector("canvas");
      if (canvas && canvas.focus) canvas.focus();
      // Some browsers need a tiny delay after focus
      await sleep(50);
    }

    async function fsWrite(path, bytes) {
      await ci.fsWriteFile(path, bytes);
    }

    async function typeCommand(cmd) {
      // Ensure DOS has focus and give it a moment
      await focusDosCanvas();
      // Clear any partial input first (press Enter)
      ci.simulateKeyPress(13);
      await sleep(30);
      // Send the whole command (uppercase/lowercase both fine)
      for (const ch of (cmd + "\r")) {
        ci.simulateKeyPress(ch.charCodeAt(0));
        // Tiny throttle helps reliability on some browsers
        await sleep(2);
      }
    }

    function buildBatBytes() {
      const lines = [
        "@echo off",
        "echo Assembling MAIN.ASM (TASM)...",
        "TASM /q MAIN.ASM > BUILD.LOG",
        "if errorlevel 1 goto ERR",
        "echo Linking MAIN.OBJ (TLINK)...",
        "TLINK MAIN.OBJ,,NUL,; >> BUILD.LOG",
        "if errorlevel 1 goto ERR",
        "echo Running MAIN.EXE...",
        "MAIN.EXE",
        "goto END",
        ":ERR",
        "echo.",
        "echo ===== BUILD FAILED =====",
        "type BUILD.LOG",
        ":END",
        "echo.",
        "echo ===== DONE ====="
      ].join("\r\n");
      return encoder.encode(lines);
    }

    async function ensureVm() {
      if (!ci) await bootVm();
    }

    async function ensureToolchain() {
      if (!tasmBuf || !tlinkBuf) await preloadTools();
      await fsWrite("TASM.EXE",  tasmBuf);
      await fsWrite("TLINK.EXE", tlinkBuf);
      if (dpmiBuf) await fsWrite("DPMI16BI.OVL", dpmiBuf);
      if (rtmBuf)  await fsWrite("RTM.EXE",      rtmBuf);
    }

    async function runBuild(sourceText) {
      localStorage.setItem(LS_KEY, sourceText);
      await ensureVm();
      await ensureToolchain();

      await fsWrite("MAIN.ASM",  encoder.encode(sourceText));
      await fsWrite("BUILD.BAT", buildBatBytes());
      for (const u of uploads) await fsWrite(u.dosName, u.bytes);

      await typeCommand("CALL BUILD");
    }

    elRun.addEventListener('click', async () => {
      try {
        elRun.disabled = true;
        elReset.disabled = true;
        elStat.textContent = "Running...";
        await runBuild(elCode.value || "");
        elStat.textContent = "Done. (VM is still running — edit and Run again)";
      } catch (e) {
        console.error(e);
        elStat.textContent = "Error: " + (e?.message || e);
      } finally {
        elRun.disabled = false;
        elReset.disabled = false;
      }
    });

    elReset.addEventListener('click', async () => {
      try {
        elRun.disabled = true;
        elReset.disabled = true;
        elStat.textContent = "Resetting VM...";
        if (props) await props.stop();
        props = null; ci = null;
        await bootVm();
        elStat.textContent = "Fresh VM ready.";
      } catch (e) {
        console.error(e);
        elStat.textContent = "Error resetting VM";
      } finally {
        elRun.disabled = false;
        elReset.disabled = false;
      }
    });

    (async () => {
      elStat.textContent = "Starting VM...";
      await bootVm();
      elStat.textContent = "VM ready.";
    })();
  }
  </script>
</body>
</html>
